#!/bin/sh
# File: ssh2vpn
# Author: Gregor Larson (2015)
# ============
# Script to create and manage ssh VPN style tunnels.
#	- tun device with private IP, not TCP tunnels.
#
# Docs: see ssh2vpn.md and README.md (hopefully bundled with this script)

# This script has multple entry-points. such that it can be used with or
# without a formal service-manager, like systemd to create a persistent tunnel.
# See example files: ssh2vpn.service ssh2vpn.conf

# This script also contains a basic service wrapper such that you can create a
# temporary tunnel without configuring a system service, by running a command
# from your terminal which will create a background process that should persist
# after you log-off.

# Install notes:
# ==============
# The recommended location to install this script is /usr/local/bin/
# however, /bin or /usr/bin will likely work as well, but you might
# need to correct a hard-coded path in the systemd .service file.
#
# Configuration notes:
# ====================
# VPN wide configuration is stored in file: ssh2vpn.rc
#	- this file can be identical on each host
#	- this file can be in /etc /root/.ssh or /site/etc
#	- see example template or more details in ssh2vpn.md
#
# *** Security considerations: see also ssh2vpn.md
# ============================
# Script will look for unencrypted private keys at:
#	- $vpnhome/id_vpn##	/run/ssh2vpn/id_vpn##
#	- $vpnhome/id_vpn	/run/ssh2vpn/id_vpn
#	Note that $vpnhome defaults to /root/.ssh
#
# TODO:	figure out what good approach is for systems without encrypted
#	root. Should id_vpn be a symlink to an encrypted volume, so
#	that the tunnel will not start at boot, but would start some time
#	later after the encrypted volumes are mounted.
#
#	The ssh2vpn status could check for local key files and agent and flag
#	an error if there is no auth information available. This would not
#	identify an error if key files and agent were being used together, or,
#	if the agent was expected to have more than one key.
#
# Script can also use your ssh-agent, or start it's own private ssh-agent
# to avoid the use of unencrypted private keys on disk.
#
# Portability:
# ============
# Currently tested only on Linux (Debian and Fedora).
#
# Bugs / TODO:
# ============

#	Figure out what good keep-alive options are, or, require these to be
#	added to ~/.ssh/config or /etc/ssh/ssh_config, or, require sshopt
#	in ssh2vpn.rc. Even with an nfs mount, there may not be sufficient traffic
#	on the ssh TCP connection to maintain a connection through a cheap NAT.
#	- It seems to me the need for keep-alive would apply to interactive ssh
#	  sessions as well, so perhaps it should be placed the ssh config and
#	  not configured via ssh2vpn.
#

# no glob
set -f

if [ "$BASH" ]; then
   # Stupid bash
   # bash builtin kill is broken
   kill() { /bin/kill "$@" ; }
   # any more bash breakage?
fi

# Logging facilities

# The strategy is to use the terminal for non-critical output, if a terminal
# is attached. When running in a service-wrapper (systemd), formal logs are
# sent to syslog using logger, but unexpected errors may still be reported
# to stdout/stderr, which will also appear in the systemd journal.
#
# ttycheck is a test to try and decide if the log function should
# syslog as well as stdout. Check needs to be done each time because
# stdout/stderr could be re-directed.
ttycheck="tty -s"

# Using systemctl, stderr (and stdout) lines appear in journal, along with
# syslog, so logs will appear twice. To avoid this, I suppress the stderr
# output if there is no tty, or use an environment variable to suppress logging
# to stderr.  systemd services have little or no environment variables, so, I
# can actually use that to detect if I am running in a service.

#hack:	use the lack of environment to detect service-mode and
#	suppress output (to avoid double-logging).
if [ "$HOME" ]; then
	syslog_only=false		#default false
	service_mode=false		#default false
else
	# running as a system service.
	service_mode=true	#true
	syslog_only=true	#true, don't log to stderr
fi

log() {
 if $syslog_only ; then
    logger -t ssh2vpn "$*"
    return
 fi
 $ttycheck || logger -t ssh2vpn "$*"
 echo "$*" >&2
}
die_rc() {
 rc=$1
 shift
 log "$@"
 exit $rc
}
die() { die_rc 7 "$@" ; }

# For now, quiet and debug flags are just files in /root/.ssh/
#	ssh2vpn_debug		- output more
#	ssh2vpn_quiet		- output less

if [ -f /root/.ssh/ssh2vpn_debug ]; then
	ssh2vpn_debug=true
	ssh2vpn_verbose=true
elif [ -f /root/.ssh/ssh2vpn_quiet ]; then
	ssh2vpn_debug=false			#default false
	ssh2vpn_verbose=false
else
	ssh2vpn_debug=false			#default false
	ssh2vpn_verbose=true			#default true
fi

bugme() { $ssh2vpn_verbose && log "$@" ; }
debug() { $ssh2vpn_debug && log "$@" ; }

# TEMP DEBUG
#{ set ; ls -l /proc/$$/fd
#} > /tmp/ssh2vpn.set

if [ "$1" = sign ]; then
   :
else
   [ "$UID" ] || UID=`id -u`
   [ $UID -eq 0 ] || die "must be run as root (${0##*/} $*)"
fi

# There is a map from un-qualified host name to a number,
# usually in the range 2 to 99. It is used as the tun number and the
# last byte of the ipv4 VPN address. If a host has multiple names in
# different situations, then add multiple mappings to the same number.
# hostnum number name [name ...]
# - note that the LAST name provided will be used when mapping from
#    the host number to name.

# There are also a maps to override the subnet prefix (first 24 bits), fqdn,
# ssh-options and tunnel MTU.

#parms: num name [name ...]
# hostmap will contain name=num ...
# - used by host_to_num function below.
# - note that an eval cannot be used to create this map because
#   host-names can contain a dash character, but shell variables
#   cannot.
hostnum() {
  local n t d
  n=$1 ; shift
  for d in $@ ; do
	hostmap="$d=$n $hostmap"
	t="$d"
  done
  # For fast num_to_host, take the last name supplied.
  # Create a variable of form:	_hostnum_{N}
  # Used by read_hostname function below.
  eval "_hostnum_$n=\"$t\""
}

#parms: num variable-name
read_hostname() { eval "$2=\"\${_hostnum_$1:-hostnum-$1}\"" ; }

# Support for alternate subnet for a host:
# The first parameter is prefix, followed by 1 or more numbers, because several
# hosts could use the same subnet. i.e. hostpref x.y.z num [num...]
#parms: prefix num [num ...]
# Creats variables of form: _prefmap_{N}={PREFIX}
hostpref() {
  n=$1 ; shift
  for d in $@ ; do
	eval "_prefmap_$d=\"$n\""
  done
}
#parms: num variable-name
read_prefix() { eval "$2=\"\${_prefmap_$1:-$vpn_prefix}\"" ; }

# Support for a non-default maximum transmisssion unit (MTU):
# Create hostnum to MTU mapping by creating variables
# of form: _mtumap_{N}={mtu-bytes}
#
#parms: MTU num [num ...]
hostmtu() {
  n=$1 ; shift
  for d in $@ ; do
	eval "_mtumap_$d=\"$n\""
  done
}
#parms: num variable-name
read_mtu() { eval "$2=\"\${_mtumap_$1:-$default_mtu}\"" ; }

# Support for fqdn override for a host number:
# Create hostnum to fqdn mapping by creating variables
# of form: _fqdnmap_{N}={FQDN}
#
#parms: num fqdn
hostfqdn() { eval "_fqdnmap_$1=\"$2\"" ; }

#parms: num variable-name
read_fqdn() { eval "$2=\"\$_fqdnmap_$1\"" ; }

# Support for additional ssh options for a host:
# Create hostnum to sshopt mapping by creating variables
# of form: _sshopt_{N}={option}
#
#parms: num option...
hostsshopt() {
	local n=$1 ; shift
	eval "_sshopt_$n=\"$*\""
}

#parms: num variable-name
read_sshopt() { eval "$2=\"\$_sshopt_$1\"" ; }

#parms: validity-period num [num...]
host_validity() {
	local val="$1"
	shift
	while [ $# -gt 0 ]; do
	   eval "_valper_$1='$val'"
	   shift
	done
}
#parms: num variable-name
read_validity() { eval "$2=\"\${_valper_$1:-$default_validity}\"" ; }

#parms: num [num...]
cert_portfwd() {
	while [ $# -gt 0 ]; do
	   eval "_portfwd_$1=true"
	   shift
	done
}

#parms: num variable-name
read_portfwd() { eval "$2=\${_portfwd_$1:-false}" ; }

# Each time hostmap mapping is used, there will be a for-loop to search the
# mapping. We couldn't use an eval because the name might contain a hyphen
# (dash-char).

# rc=0 no mapping found
# rc>0 rc=hostnum
#parms: name
host_to_num() {
  local m
  # if a number is provided, just return it.
  case $1 in [1-9]|[1-9][0-9]) return $1 ; esac

  for m in $hostmap ; do
     case "$m" in $1=*) return ${m#*=} ; esac
  done
  return 0	# no mapping found
}

#parms: num
# rc=0 success
valid_hostnum() { eval "[ \"\$_hostnum_$1\" ]" ; }

# Don't use a personal agent when running ssh2vpn at a terminal.
# This is a recommended setting if you are using systemd service wrapper
# because ssh2vpn status output will warn you when no authentication information
# is available.
no_personal_agent() {
  unset SSH_AUTH_SOCK
  unset SSH_AGENT_PID
}

# These are defaults. You can override these in ssh2vpn.rc
# if needed.
vpn_prefix=10.99.1
pid_dir=/run/ssh2vpn
agent_sock=$pid_dir/agent
omitd=/run/sendsigs.omit.d
ifconf=/proc/sys/net/ipv4/conf
vpnhome=/root/.ssh
# TODO:  figure out what a good MTU is for NFS
#	- should the MTU match the rsize/wsize?
# By default, leave TUN MTU unchanged.
default_mtu=0

# Setting expect_remote to false in the rc file, for systems where we are not
# expecting any incoming sessions, can avoid some noise messages about PermitTunnel.
expect_remote=true

# Allow an rc={filename} initial parameter
unset rc_file
case "$1" in rc=*)
	rc_file="${1#rc=}" ; shift ;;
esac

# rc files can override vpn_prefix, fqdn etc.
if [ "$rc_file" ]; then
   debug "including rc_file=$rc_file"
   . $rc_file
elif [ -f /etc/ssh2vpn.rc ]; then
   debug "including /etc/ssh2vpn.rc"
   . /etc/ssh2vpn.rc
else
   # /site is a non-standard directory used by author.
   [ -f /site/etc/ssh2vpn.rc ] && . /site/etc/ssh2vpn.rc
fi

if [ -f $vpnhome/ssh2vpn.rc ]; then
   debug "including $vpnhome/ssh2vpn.rc"
   . $vpnhome/ssh2vpn.rc
fi

[ "$HOSTNAME" ] || HOSTNAME=`hostname`
[ -d $pid_dir ] || mkdir -p $pid_dir

# start tunnel command
# Setup the common names to be passed implicitly to all sub-functions:
#	rnum desthost
#
#parms: start|persist host-name|number	(from commmand-line)
do_start() {
 if [ "$1" = persist ]; then
    persist=true
    # If the user has selected 'persist' then they may not
    # use their personal ssh-agent.
    no_personal_agent
 else
    persist=false
 fi
 shift

 host_to_num "$1" ; rnum=$?
 if [ $rnum -eq 0 ]; then
    die "unknown host: $1"
 fi
 if [ $rnum -eq $local_hostnum ]; then
    die "host=$1 : tunnel to self($rnum) not allowed."
 fi
 # If only a number was provided, that will not work unless an
 # fqdn mapping was provided in ssh2vpn.rc
 # We can allow a basic name mapping here, however, that may not
 # work in all cases, because it will take the last mapping
 # value.
 case "$1" in [1-9]|[1-9][0-9])
	read_hostname $1 desthost	;;
 *)	desthost=$1
 esac

 if [ -f $pid_dir/systemd.$rnum ]; then
    # this tunnel is managed by systemd service
    # see /etc/systemd/system/vpn-{name}.service
    die "Error: use systemd to manage this tunnel($1)($rnum)"
 fi

 # Set a file flag to indicate the tunnel is persistent
 #  - The persistent flag is NOTE removed if the tunnel is started again
 #    without the persist flag.
 #  - The ONLY way to clear the persist flag is to stop the tunnel.
 #  - The persist flag will not survive reboots because it is on a tmpfs.
 #
 $persist && touch $pid_dir/$rnum.persist

 ssh2vpn_start $rnum $desthost
}

# Start an ssh tunnel, including daemon and tun configuration.
#parms: rnum desthost		(implicit)
ssh2vpn_start() {
 # rnum=$1 ; desthost=$2

 # The tun device on this host gets the remote number.
 tun=tun$rnum
 tconf=$ifconf/$tun

 sig_rcvd=
 trap "sig_rcvd=usr1" USR1
 trap "sig_rcvd=usr2" USR2
 cmdshell_pid=$$

 # DEBUG check that $$ is actually my pid
 #read mypid junk < /proc/self/stat
 #unset junk
 #[ $mypid -eq $cmdshell_pid ] || log "ERROR: mypid=$mypid cmdshell_pid=$$"
 # END DEBUG 

 # The daemon must be running before configuration of the tun
 # can be attempted. start_tun_daemon will return true if daemon
 # starts or we are reusing existing daemon.
 if start_tun_daemon $rnum $desthost ; then
    debug "host=$desthost cmdshell=$cmdshell_pid tun daemon running."
 else
    log "host=$desthost cmdshell=$cmdshell_pid failed to start daemon."
    return 1
 fi

 # Is there race conditions where the signal is sent before we wait?
 # If we are re-using an existing daemon, I assume there will be
 # nothing to wait for?
 debug "cmdshell($$) sig=$sig_rcvd waiting for signal from daemon."
 [ "$sig_rcvd" ] || wait

 debug "ssh2vpn_start($$) sig=$sig_rcvd"

 # The tun daemon is now running, so we can configure the tun.
 if [ ! -d $tconf ]; then
    # The daemon did not create the tun device, probably because
    # of a configuration issue with ssh/sshd/
    # Could also be a race condition?
    log "host=$desthost missing tunnel rnum=$rnum"
    return 2
 fi

 # TODO: use the sig_rcvd to get the result from the daemon
 #	rather than doing another check here.
 hostnum_status $rnum $desthost
 return $?
}

# exec an ssh client (function does not return)
# This function exists to expose the ssh command to an external
# service manager (for example systemd). It writes it own .pid
# file using $$ so this function should not be used internally
# and should only be called via MAIN.
#
#parms: rnum desthost	(from ssh2vpn.service systemd)
exec_ssh_service() {
 debug "exec_ssh_service($$) $*"
 # rnum and desthost are needed by other functions.
 rnum=$1
 if [ "$2" ]; then
    desthost=$2
 else
    # Allow the hostname to be omitted. This will make it easier
    # to create a general systemd @service wrapper.
    read_hostname $1 desthost
 fi

 cd $pid_dir
 [ -f $1.pid ] && die "Error: ssh_service pid file already exists."
 echo $$ > $1.pid
 exec_ssh	# rnum desthost (implicit)
}

# Wait for tun to be create and apply settings to tun
# This function is coded such that it should be useable from internal
# managers as well as external managers (ssh2vpn servicetun).
# The rc indicates success or failure.
#
# The optional pid parm indicates the pid of the ssh process.
# If it is not included, then, the pid value will be retrieved
# from the pid file.
#
#parms: rnun [pid]	(internal, or from systemd ssh2vpn.service)
service_tun() {
 rnum=$1		# for use by other functions

 if [ "$2" ]; then
    pid=$2
 else
    # Race condition where pid file is not created fast enough
    # by exec_ssh_service?
    [ -f $pid_dir/$1.pid ] || sleep 1

    if [ -f $pid_dir/$1.pid ]; then
       read pid < $pid_dir/$1.pid
    else
       die "operation error, no $pid_dir/$1.pid"
    fi
 fi

 # Wait for the tun device to be created
 wait_for_tun $1 $pid ; wrc=$?
 case $wrc in
 0)	update_tun $1 ;;	# success, update the tun
 1)	log "wait_tun=$wrc ssh exited" ;;
 2)	log "wait_tun=$wrc timeout waiting" ;;
 3)	log "wait_tun=$wrc signal received" ;;
 *)	log "wait_tun=$wrc unknown"
 esac
 return $wrc
}

# Utility to wait for ssh to create tun
# rc=0 found tun
# rc=1 pid gone
# rc=2 timeout
# rc=3 signal received
#
#parms: rnum ssh-pid [secs]
wait_for_tun() {
 max=${3:-90}
 x=0
 while true; do
   [ -d /proc/$2 ] || return 1		# PID gone
   [ -d $ifconf/tun$1 ] && return 0	# Found TUN

   # depends on a trap set previously that will assign sig_rcvd
   [ "$sig_rcvd" ] && return 3		# SIGNAL received

   x=$(($x + 1))
   if [ $x -eq 10 -o $x -eq 30 -o $x -eq 60 -o $x -eq $max ]; then
      log "ssh($2) did not create tun$1 after $x secs"
   fi

   [ $x -lt $max ] || return 2		# TIMEOUT
   sleep 1
 done
}

# exec an ssh client (function does not return)
# This function exists to allow ssh to be started via an internal
# manager (daemon_cmd) or an external service manager
# (for example systemd).
#
# No pid file is created in this function. The calling function
# or service manager creates the pid-file.
#
# The calling function or service manager must decide what to do with
# stdin,out,err from this function. This function could produce some output,
# however, the caller should not leave this function attached to a terminal.
#	- output from this function could appear in the systemd journal
#
#parms: rnum desthost	(implicit)
exec_ssh() {
 $ssh2vpn_debug && echo "stdout ssh2vpn::exec_ssh $rnum $desthost"

 # Get authentication information (agent environment, ssh_id_opt).
 if get_auth; then
    debug "found authentication ($desthost)"
 else
    log "Missing authentication data for ($desthost)"
    exit 1
 fi

 # in case there is an fqdn override
 read_fqdn $rnum destfqdn
 [ "$destfqdn" ] || destfqdn=$desthost

 # The ssh -w command takes {local-tun-number}:{remote-tun-number}
 # We name the local-tun based on the remote host number.
 #
 # For this to work, a private key must be available to allow ssh to
 # authenticate itself to the destination host. An private or user
 # ssh-agent can be used, however, a users ssh-agent will not be suitable
 # if we intend to re-establish the ssh-tunnel automatically, because
 # the ssh-agent would not be available later. A private ssh-agent can be
 # created which contains only the keys needed by ssh2vpn (see get_agent above).
 #
 # A private key on disk is exposed to mis-use because it is protected
 # only by the filesystem, and not encrypted with a passphrase. For this
 # reason, the private key on disk needs to be a single-purpose private
 # key that can only be used to setup a tunnel, and not a general purpose
 # key for interactive login. The ~/.ssh/authorized_keys2 file should restrict
 # the use of the key (for example):
 #
 # no-pty,no-X11-forwarding,no-port-forwarding,no-user-rc,tunnel="5",command="ssh2vpn force 5" ssh-rsa ...key ...comment
 #
 # Option to consider:
 #	-n	= stdin < /dev/null
 #	-T	= disable pseudo-tty allocation
 #	TODO: is there an option to disable interactive password?
 #		- may not be necessary with -n
 #	If debug is enabled, we might want -v
 #
 # Get any additional options
 read_sshopt $rnum xtr

 remcmd="ssh2vpn from $HOSTNAME $local_hostnum $rnum"
 sshcmd="ssh $ssh_id_opt -nT -w $rnum:$local_hostnum $xtr $destfqdn"
 bugme "agent($SSH_AUTH_SOCK) $sshcmd $remcmd"
 # If we do no redirect stdout, then any output from ssh may appear
 # in systemd journal.
 exec $sshcmd "$remcmd"
 # we do not expect exec to return
 die "exec failed: $sshcmd"
}

#
# Get authentication environment and shell variables
#	- check for key files
#	- check for and setup agent environment
#	- note that this function may allow a personal agent to be used when running
#	  from the command-line, and, no ssh2vpn agent is currently running.

# This will be used in the status command, as well as the exec_ssh function (above).
# Note that this function indicates the availability of keys, however, it cannot
# indicate the validity of keys for any specific host.
# returns:
#	rc=0: Some authentication keys available.
#	rc=1: No authentication keys available.
#	ssh_id_opt
#	agent environment: SSH_AUTH_SOCK SSH_AGENT_PID
#
get_auth() {
 get_identity		# get ssh_id_opt
 get_agent && return 0
 [ "$ssh_id_opt" ] && return 0
 # No agent and no identity.
 return 1
}

# Run ssh in background, detached from terminal and manage tun.
# This function is used when starting the tunnel via a terminal
# command rather than a formal service manager (systemd).
#
# Make a .pid file (for the ssh process) and wait.
# Note that the caller must record the pid-file of THIS manager
# sub-shell in file mgr.{host-num}.pid, which will be deleted by
# this thread before it exits.
#
# This function will normally be run in the background so the shell
# sub-process can manage the .pid file.
#
# Because this is run in background, and the parent proc does not
# wait, any rc is ignored.
#
# It expected that stdin,out,err is already redirected when daemon_cmd 
# is called in order to detach from the terminal.
#
# Based on the {host-num}.persist file flag, this function will restart
# the daemon after it exists, or just exit itself.
#
#parms: rnum desthost		(required)
daemon_cmd() {
 rnum=$1 ; desthost=$2 ; shift ; shift

 # NOTE: if needed, this manager shell pid could be saved in a file
 #       (get it from /proc/self/stat). $$ refers to invoking shell.
 # Add a trap handler for SIGTERM(15) in case shutdown is run and
 # we get a signal.
 sig_rcvd=
 trap "sig_rcvd=term" TERM
 trap "sig_rcvd=usr1" USR1

 cd $pid_dir
 pidfile=$pid_dir/$rnum.pid
 persistf=$pid_dir/$rnum.persist
 mgrpidf=$pid_dir/mgr.$rnum.pid

 # Get the REAL process-id for me.
 read mypid junk < /proc/self/stat
 unset junk
 sleep 0.1	# allow caller to create the $mgrpidf

 while true; do
   # Verify the the manager pid-file, created by the caller of this
   # function actually matches. If it does not match, this indicates
   # one of several problems:
   #	- the manager pid file was deleted by something.
   #	- the manager pid file was not created.
   #	- the manager pid file is still being created (race condition).
   #	- there is another instance of the manager.
   [ -f $mgrpidf ] || die "$mgrpidf missing. Manager exiting."
   mpid=
   read mpid < $mgrpidf
   [ -z "$mpid" ] && die "$mgrpidf empty. Manager exiting."
   [ $mpid -eq $mypid ] || die "Manager pid mismatch ($mypid) found $mpid. Manager exiting."

   exec_ssh &	# rnum desthost (implicit)
   pid=$!
   # pid refers to the ssh client

   # The following is a manager for the ssh process we just created.  This is
   # used in the case ssh2vpn is run from the command-line and not as a systemd
   # service. A pid-file created and removed later after the ssh client
   # completes.

   echo $pid > $pidfile

   # Link this pidfile such that it is omitted from sendsigs (first pass) during
   # shutdown. Hopefully, this will allow NFS to unmount while the tunnel is
   # still running.

   if [ -d $omitd ]; then
      [ -e $omitd/$rnum.ssh2vpn ] || ln -sf $pidfile $omitd/$rnum.ssh2vpn
   fi

   # service the tun device, wait for it to be created and update it
   if service_tun $rnum $pid ; then
      cmdsig=USR1		# USR1 will signal success
   else
      cmdsig=USR2
   fi

   # Signal the command shell that we are no longer waiting for initial tun to be
   # created. Note that the bash builtin kill does not work so there is a
   # function defined above.
   #
   # This signal, and associated wait in ssh2vpn_start are only useful for a
   # command that blocks and returns a success/fail indication after the initial
   # tun is created.
   #
   # If we don't need to delay subsequent work and the rc is not being used, then
   # this wait/signal work could be eliminated. This signaling mechanism would
   # not make sense for a persistent tunnel because the command shell would not
   # be waiting.

   if [ "$cmdshell_pid" ]; then
      if [ -d /proc/$cmdshell_pid ]; then
	 kill -$cmdsig $cmdshell_pid
	 debug "kill -$cmdsig $cmdshell_pid rc=$?"
      fi
      # Only signal once.
      cmdshell_pid=
   fi

   while [ -d /proc/$pid ]; do
      debug "waiting for $pid: $sshcmd $remcmd"
      wait $pid ; ssh_rc=$?
      # Note that the wait will return if we get a signal OR the ssh process ends.
      # If we want to get the rc from ssh process, we might need to specify
      # wait $pid, however, we would need to check if $pid is still running
      # to tell if the rc was valid. So, ssh could still be running.
      if [ -d /proc/$pid ]; then
         log "host=$desthost ssh ($pid) still running. rc=$ssh_rc sig=$sig_rcvd"
         sig_rcvd=
         # This probably means shutdown is happening (we got a signal)
         # but the tunnel (ssh) is still running.
         # We could run some cleanup code?
      fi
   done
   bugme "host=$desthost ssh ($pid) exited. rc=$ssh_rc sig=$sig_rcvd"
   rm -f $pidfile

   # Paranoid check for collision between a systemd instance and a
   # command-line instance.
   if [ -f $pid_dir/systemd.$rnum ]; then
      log "Error: collision with systemd manager"
      break
   fi

   # If persistent flag is set, wait and loop
   [ -f $persistf ] && sleep 63
   [ -f $persistf ] || break
 done

 bugme "host=$desthost daemon ending"

 # remove the pid-file and persist flag for this manager thread
 rm -f $mgrpidf $persistf $omitd/$rnum.ssh2vpn
}

# Start the ssh tunnel in a sub-shell with .pid file and
# and return immediately.
# The ssh2vpn script must exist on path at destination host.
#
# Caller must check rc to see if operation succeeded.
# rc=0 if started or reused.
#
# This utility does not configure tun or check if it
# was created as expected, however, it does detect a
# collision where the tun already exists.
#
#parms: rnum desthost		(implicit)
start_tun_daemon() {
 # rnum=$1 ; desthost=$2

 if daemon_running $rnum ; then
    log "re-using existing daemon for host=$desthost"
    # In the re-use case, we update then tun settings in case it
    # was not done initially, or, ssh2vpn.rc settings changed since
    # it was originally done.
    update_tun $rnum
    return 0
 fi

 # Check if requested local tun is available on this host
 if [ -d $ifconf/tun$rnum ]; then
    log "Requested tun$rnum already in-use for host=$desthost"
    return 3
 fi

 # If this does not properly detach from process group/pty then
 # I might need to do. Tested this and it performs similar to starting
 # daemon_cmd directly. Need to consider if start-stop-daemon is available
 # on non-debian systems. Also need to consider rc_file and any other parameters
 # that might need to be passed on.
 #
 # start-stop-daemon --start -x "$0" -- daemon "$@" < /dev/null > /dev/null 2>&1 &
 #	the daemon option is handled by this script (MAIN bottom).
 #
 # If started via a terminal, redirect stdin,out,err to detach from terminal.
 daemon_cmd $rnum $desthost < /dev/null > /dev/null 2>&1 &

 # Keep pid-file for the management thread.
 echo "$!" > $pid_dir/mgr.$1.pid
 # Give daemon time to start (or fail) before checking.
 sleep 1
 if daemon_running $1 ; then
    debug "host=$desthost new daemon found running."
 else
    log "failed to start daemon for host=$desthost"
    return 2
 fi
 return 0
}

# Not quoting HOSTNAME. Not sure I want to support wierd host names.
# There must be a mapping from the HOSTNAME.
#
host_to_num $HOSTNAME ; local_hostnum=$?
[ $local_hostnum -gt 0 ] || die "local_hostnum ($HOSTNAME) unknown."

# status command
# If no host-name is provided, the pid directory and existing tun
# are scanned.
#parms: [host-name]
do_status() {
 if [ "$1" ]; then
    case "$1" in [1-9]|[1-9][0-9])
	hostnum_status $1
	return $?
    esac
    host_to_num "$1" ; status_num=$?
    if [ $status_num -gt 0 ]; then
       hostnum_status $status_num $1
       return $?
    fi
    log "no hostnum for $1"
    return 3
 fi

 # No arg, so default is to show all, by scanning .pid files.
 for p in `ls $pid_dir` ; do
    case "$p" in *.pid) pn=${p%.pid}	;;
    # only consider *.pid files
    *) continue
    esac

    # The pid file may correspond to a local ssh, remote sshd or
    # ssh2vpn (this script file).

    case "$pn" in mgr.*)
	# manager (an instance of this script)
	hostnum_status ${pn#mgr.}
	continue	;;
    remote.*)
	# remote sshd
	hostnum_status ${pn#remote.}
	continue	;;
    esac

    # Not a manager thread, or a remote connection. This is a local daemon,
    # so, check if a manager exists. We don't want to run the status twice
    # on a host number, so, if a manager exists then skip this .pid
    #
    [ -f $pid_dir/mgr.$pn.pid ] && continue

    # No associated manager thread. This could be due to the manager
    # in this script failing or being killed, however, it could also
    # be because systemd is being used as the manager.
    #

    # TODO: Move check and error message to hostnum_status

    # Note that the systemd.$pn flag is created and removed in the
    # systemd config file.
    [ -f $pid_dir/systemd.$pn ] || log "Error: no manager for host num: $pn"

    hostnum_status $pn
 done
 # Scan for any extra tun devices not accounted for.
 _scan_tuns

 # Check for authentication information
 no_personal_agent
 if get_auth; then
    bugme "Authentication Keyfile: ${ssh_id:-none} Agent: ${SSH_AUTH_SOCK:-none} ($SSH_AGENT_PID)"
 else
    bugme "Warning: no global authentication keys available."
 fi

 if $expect_remote; then
    # If we expect to have incoming vpn connections, then an option
    # PermitTunnel is required in sshd_config
    if grep -qi '^[^#]*PermitTunnel[[:space:]]*yes' /etc/ssh/sshd_config ; then
       :
    else
       echo "Warning: PermitTunnel not in sshd_config. Remote connections will fail."
    fi
 fi
}

# This will become the main status entry point.
#
# In the case where do_status is iterating over the
# .pid files, there will be some minor duplication of
# work, because the .pid file was already found, but here
# we check it again. We will accept that cost.
#
# In the case where the user provides a name on the command-line,
# that name will be mapped to a valid number prior to calling
# this function, however, the provided name will be included as
# well, mostly for messages.

# rc=0 OK
# rc>0 Problems detected.
# For most uses of this function true/false rc will be sufficient, however,
# I will try a mask to return more detail. I can pull this out later if
# it is excessive. Bits (0=OK):
#	1 = pidfile or daemon not found.
#	2 = tun does not exist
#	4 = tun exists but not properly configured
#	8 = expected manager pidfile or process not found.
# 	16 = usage or internal error

# One challenge for this function is wrt remote sessions.
# The .pid file for remote sessions is not removed when the
# session exits.
#
#parms: rnum [name]	(required)
hostnum_status() {
 debug "hostnum_status($@)"
 local persist=false

 [ "$1" ] || die "hostnum_status usage."
 if [ -z "$2" ]; then
    read_hostname $1 status_host
 else
    status_host=$2
 fi

 if [ -f $pid_dir/remote.$1.pid ]; then
    remote=remote.
    status_exe=sshd
 else
    remote=
    status_exe=ssh
 fi

 msg="$remote$1($status_host)"
 if local_running $remote$1 $status_exe ; then
    debug "	$msg daemon running"
    running=running
    daemon_rc=0
 else
    debug "	$msg daemon not running"
    running=stopped
    daemon_rc=1
 fi
 msg="$remote$1($status_host) $running"

 if [ $1 -eq $local_hostnum ]; then
    # a tunnel conntection to self does not make sense.
    log "$msg self not expected."
    return 16
 fi

 # Keep a set of tuns checks for use in the _scan_tuns
 eval "_tun_${1}_host=$status_host"

 # Check the status of the TUN device
 # 0=OK 2=missing 4=configuration-error
 tun_status $1 ; tun_rc=$?
 if [ $tun_rc -eq 0 ]; then
    msg="$msg tun$1 ok"
 elif [ $tun_rc -eq 2 ]; then
    if [ "$running" = stopped ]; then
       # No daemon (ssh/sshd) and no tun, so, the tun is not actually
       # expected or 'missing'. Really, the only thing we could tell the
       # user is that there was a remote connection at some time in the
       # past.
       msg="$msg cleanup ok."
    else
       # We expected the tun device to be found so consider it missing.
       msg="$msg tun$1 missing"
    fi
 else
    msg="$msg tun$1 fault"
 fi

 # Lastly, we check the manager and perist flag and output a line
 # of status.
 if [ -f $pid_dir/$1.persist ]; then
    msg="persistent $msg"
    persist=true
 fi

 mgr_rc=0
 sd_managed=false
 if [ -f $pid_dir/systemd.$1 ]; then
    # systemd managed
    echo "sd-managed $msg"
    sd_managed=true
 elif local_running mgr.$1 ssh2vpn ; then
    if [ "$remote" ]; then
       log "ERROR: unexpected manager for remote connection: $1($status_host)"
       mgr_rc=8
    else
       echo "managed $msg"
    fi
 else
    # The manager is not running. This is not necessarily a problem,
    # because remote sessions do not have a manger.
    if [ "$remote" ]; then
       # The following echo is producing to much output for remote
       # connections that ended normally.
       echo "unmanaged $msg"
       # ok, so this is a remote connection (no manager)
    else
       echo "$msg. Manager stopped. Daemon $running"
       mgr_rc=8
    fi
    if $persist ; then
       # The persistent flag requires a manager thread.
       log "ERROR: persistent flag, but no manager. ($1)($status_host)"
       mgr_rc=8
    fi
 fi

 if [ -d $omitd ]; then
  # link to shelter daemon from sendsigs
  shelter=$omitd/$1.ssh2vpn
  if [ -f $shelter ]; then
    if [ $daemon_rc -eq 0 ]; then
       debug "found: $shelter"
    else
       log "leftover: $shelter"
    fi
  else
    if [ $daemon_rc -eq 0 ]; then
       # Daemon running but no shelter. For systemd we are
       # not using the shelter. TODO: additional testing to
       # see if we need the shelter for incoming tunnels or
       # systemd managed tunnels on Debian based systems.
       $sd_managed || log  "missing: $shelter"
    fi
  fi
 fi

 # The daemon, manager and tunnel rc are combined
 return $(($daemon_rc + $mgr_rc + $tun_rc))
}

# Check if ssh daemon is running. Checks only the pid-file and
# process. Does not check the tun file.
#
# Currently this handles hostname, number and remote.number,
# however, hostname and remote.number are to be depricated
# and only number will be supported.
#
# Note that we also consider the remote session as a daemon, so
# that indicates running as well.
#
# rc=0 indicates pid file and ssh or sshd process found
# If needed a more specific rc can be had via local_running directly.
#
# Also returns running_pid (by side-effect), if there is a valid ssh/sshd
# process.
#
# Also deletes stale .pid files.
#parms: dest-host|num
#  num is more efficient (if caller happens to have both).
#  normally, num is supplied except for ssh2vpn stop name
daemon_running() {
  # The pid file is now named for the host-num
  local dn
  case "$1" in [1-9]|[1-9][0-9]) dn=$1 ;;
  *) host_to_num "$1" ; dn=$?
     log "daemon_running depricated use: $1"
  esac
  local_running "remote.$dn" sshd && return 0
  local_running "$dn" ssh && return 0
  return 1
}

# Look for a pid-file based on name with a given exename.
# rc=0 found matching, running_pid is the process found.
# rc=1 no pidfile
# rc=2 no process found (pid file is deleted)
# rc=3 pidfile does not match process (pid file is retained for debugging)
#
# Also returns running_pid (by side-effect), ONLY if there is a running
# process that matches the specified exe.
#
#parms: pid-name exename
local_running() {
 running_pid=
 local pidfile=$pid_dir/$1.pid
 [ -f $pidfile ] || return 1		# FALSE, no pidfile

 read running_pid < $pidfile
 if [ ! -d /proc/$running_pid ]; then
    rm -f $pidfile		# delete stale pid file
    running_pid=
    return 2				# FALSE, no process
 fi

 read running_exe < /proc/$running_pid/comm
 case "$running_exe" in
 $2) return 0		;;		# TRUE, found exe
 esac
 log "Unexpected exe ($running_exe) for host=$1"
 # If we delete the pid file here, we could mask an error?
 # For now, require manual delete, or overwrite with new.
 # rm -f $pidfile
 running_pid=
 return 3				# FALSE, unexpected exe
}

# See also hostnum_status
# The rc from tun_status function is combined with
# other rc, so only valid rc are:
#	rc=0 OK
#	rc=2 Missing tun
#	rc=4 Tun not configured
#parms: rnum
tun_status() {
 local tun=tun$1
 local tunconf=$ifconf/$tun
 local tun_rc=0

 if [ ! -d $tunconf ]; then
    # For remote connections, we may be running tun_status for hostnum
    # where we don't really expect to find a tun, in which case it is
    # more interesting if we DO have a tun, without a remote connection or
    # manager.
    debug "	missing $tun"
    return 2
 fi

 # tun exists, so check its status....

 if ip addr show dev $tun | fgrep -q ,UP, ; then
    debug "	$tun is up"
 else
    echo "	$tun not up"
    tun_rc=4
 fi

 # cloned from update_tun
 # allow override of the subnet
 read_prefix $local_hostnum local_prefix
 read_prefix $1 peer_prefix

 f="inet $local_prefix.$local_hostnum"
 if ip addr show dev $tun | fgrep -q "$f" ; then
    debug "	$tun has $f"
 else
    echo "	$tun missing $f"
    tun_rc=4
 fi
 f="peer $peer_prefix.$1/32"
 if ip addr show dev $tun | fgrep -q "$f" ; then
    debug "	$msg $tun has $f"
 else
    echo "	$msg $tun missing $f"
    tun_rc=4
 fi
 # ... could also check for scope global
 return $tun_rc
}

_scan_tuns() {
 # I also scan for extra tun devices without pids
 # This uses the _tun_#_host variables set above to detect
 # tun devices not associated with a running daemon.
 for t in `ls $ifconf` ; do
   case "$t" in tun*) ;;
   # only consider tun* devices
   *) continue
   esac
   tnum=${t#tun}
   eval "h=\$_tun_${tnum}_host"
   if [ "$h" ]; then
      # echo "	host=$h found $t"
      :
   else
      echo "Extra $t found without any .pid"
   fi
 done
}

# Force command (using authorized keys, command='ssh2vpn force {scope}')
# or the force-command option in the certificate.
# $SSH_ORIGINAL_COMMAND is the parms
do_force() {
  debug "force($*) cmd=$SSH_ORIGINAL_COMMAND"

  allowed=$1 ; shift

  # The following is the SSH_ORIGINAL_COMMAND
  # I want to allow the same command syntax to be usable with a forced
  # key command and regular ssh2vpn from command.
  #
  if [ "$1" = ssh2vpn ]; then
     shift
  else
     log "Error: force: expected ssh2vpn"
  fi

  if [ "$1" = from ]; then
     shift
  else
     log "Error: force: expected from"
  fi

  # The remaining parameters should be the same as ssh2vpn from, however,
  # we screen the requested tunnel.
  if [ $allowed = any ]; then
     debug "Allowed $* (any)"
  elif [ "$2" = "$allowed" ]; then
     debug "Allowd $* (hostnum)"
  else
     read_prefix "$2" host_vpn_prefix
     if [ $host_vpn_prefix = $allowed ]; then
        log "Allowed $* (prefix $allowed)"
     else
        die "Deny: $* ($host_vpn_prefix) not allowed($allowed) for this key."
     fi
  fi

  do_from "$@"
  return $?
}

# Start destination half of tunnel, invoked by ssh ssh2vpn from ...
# Hopefully, the tun now exists and has been created by this ssh session
#	- difficult to check if tun was actually created by this session.
#
# Note that the from-local and from-remote will be inverted here, that
# is, from-local will now become remote, and from-remote will be local.
#
#parms: from-host from-local-num from-remote-num	(required)
do_from() {
 desthost=$1 ; rnum=$2		# for consistency and other functions
 syslog_only=true		# force logger

 [ $# -eq 3 ] || die "from: usage: ($*)"

 # The remote number must match our local host number.
 # In the future, I suppose I could allow a scenario where local_hostnum
 # is not defined, in which case I would set the local_hostnum here.
 #
 if [ $local_hostnum -eq 0 ]; then
    local_hostnum=$3
    log "do_from($1) setting local_hostnum=$3"
    # There are probably some other things needed to make this work, also,
    # the ssh2vpn commands on this host probably won't work properly.
 elif [ $local_hostnum -ne $3 ]; then
    die "from_host=$1 Mismatched local_hostnum ($local_hostnum not $3)."
 fi

 # We don't wait for tun be be created in the 'from' case.
 # It should already be created before this script is run.
 from_tun=tun$rnum
 from_conf=$ifconf/$tun
 if [ ! -d $from_conf ]; then
    die "from_host=$desthost Tun device not created."
 fi

 # Here, we can put something in the pid file....
 # Ideally, we would like to put the sshd in there, however, that might
 # be difficult to find in all situations. Currently, it looks like
 # PPID will reference the sshd when ssh2vpn is invoked from ssh
 # command-line.

 # We don't expect the pid-file to already exist.
 if daemon_running $rnum ; then
    die "from_host=$desthost found daemon already running."
 fi

 from_exe=`readlink /proc/$PPID/exe`
 case "$from_exe" in *sshd) ;;
 *) log "from_host=$desthost from_exe=$from_exe"
 esac

 # This may overwrite an existing stale pid-file in some cases.
 pidfile=$pid_dir/remote.$rnum.pid
 echo $PPID > $pidfile

 # pidfile is done, tun exists, so configure it.
 update_tun $rnum

 # Shelter the sshd (child) from sendsigs in case we want to keep in
 # running a bit longer (debian based systems). On Fedora/Redhat
 # systemd-based systems, the service config file may be able
 # to control how this works, by making NFS depend on the ssh
 # service and perhaps using:
 #	KillMode=
 #
 [ -d $omitd ] && ln -sf $pidfile $omitd/$rnum.ssh2vpn

 # So, if we exit here, the sshd will continue.
 # There is no easy way to wait on the parent PID, so, the pidfile
 # will become stale. The local_running (status functions) handle cleanup.

 # TODO: consider if a watcher thread would be useful.  If the only thing the
 # watcher thread is doing is deleting the stale pid file, then it is probably
 # not worth it, however, if cleanup code becomes important, that might be a
 # valid reason to have a watcher. For a simple point2point VPN, there is
 # no real cleanup to do.

 # from_daemon "$@" < /dev/null > /dev/null 2>&1 &
 # echo $! > $pid_dir/mgr.$rnum.pid
}

# The remote-host is required for subnet override
# See also tun_status which clones a bit of this logic
#
#parms: rnum
update_tun() {
 local tun=tun$1

 read_mtu $1 tun_mtu
 if [ $tun_mtu -eq 0 ]; then
    # if mtu is 0, then leave system default
    mtu=
 else
    # override mtu value on tunnel
    mtu="mtu $tun_mtu"
 fi

 ip link set $tun up $mtu

 #TODO: figure out if we need to remove an old address before
 #	adding this address.
 #	perhaps:	ip addr flush dev $tun

 #TODO:	allow modification to resolv.conf to direct to VPN
 #	- requires robust VPN shutdown

 #NOTE:	The following list of TODO items are not required if I am simply building
 #	a peer-to-peer mesh VPN. In fact, the peer-to-peer ONLY approach is more
 #	secure (for unencrypted protocols like DNS, HTTP, NFS, SQL, SQUID, TELNET,
 #	TFTP, LDAP, SYSLOG, IRC, SMTP, VNC etc).

 #TODO: allow adding a $peer_size to the peer address to indicate a subnet
 #	rather than a single address is reachable via $tun

 #TODO: allow adding additional route entries to indicate that the far-end
 #	host supports some forwarding, routing or NAT function.
 #		- sometimes called split tunnelling
 #	ip route add {somenet} via $peer_prefix.$1
 #	- of course, once we start adding route entries, the VPN shutdown
 #	  logic becomes more critical.
 
 #TODO: allow making the VPN the default route
 #	- add specific route(s) to keep the ssh connection working.
 #	- remove the default route (or make it lower priority)
 #	- add a default route via the tun: route add 0.0.0.0/0 via $peer_prefix.$1

 #TODO: allow configuration of local forwarding or an iptables NAT
 #	on this host.
 #	echo 1 > /proc/sys/net/ipv4/conf/$tun/forwarding
 #or	echo 1 > /proc/sys/net/ipv4/ip_forward
 #	iptables -t nat -I POSTROUTING -s $peer_prefix.$1$peer_size -j MASQUERADE
 #	- of course, once we start adding iptables and forwarding, the VPN
 #	  shutdown logic becomes more critical.

 # allow override of the subnet
 read_prefix $local_hostnum local_prefix
 read_prefix $1 peer_prefix
 ip addr add $local_prefix.$local_hostnum/32 peer $peer_prefix.$1 dev $tun
}

# stop command
#parms: hostname|num
do_stop() {
  host_to_num "$1" ; stop_num=$?
  [ $stop_num -eq 0 ] && die "No host matching $1. Cannot stop."

  if [ -f $pid_dir/systemd.$stop_num ]; then
     # this tunnel is managed by systemd service
     # see /etc/systemd/system/ssh2vpn.service
     die "Error: use systemd to manage this tunnel($1)($stop_num)"
  fi

  persistf=$pid_dir/$stop_num.persist
  [ -f $persistf ] && rm $persistf

  if daemon_running $stop_num ; then
     bugme "host=$1 stopping."
     kill $running_pid
  else
     bugme "host=$1 already stopped."
  fi
}

# Get the on-disk identity (key, certificate) to authenticate
# the ssh command. Note that this identity cannot be protected
# by a passphrase because the daemon runs in the background and
# will not be connected to a user.
#
# If a passphrase strategy is wanted, then instead use ssh2vpn agent
# and add the keys to that agent (which allows an interactive prompt
# for a passphrase).
# Returns (by side-effect):
#	ssh_id
#	ssh_id_opt
get_identity() {
   # The preferred name is id_vpnXX (and id_vpnXX-cert.pub).
   # Where XX is the local host number.
   # If that is not available, then id_vpn (and id_vpn-cert.pub)
   # are tried.
   #
   # Looks in $pid_dir and $vpnhome (/root/.ssh) for identity file.
   # Note that HOME is not set for systemctl service.
   #
   # It is possible for the ssh_id to be provided via the ssh2vpn.rc
   # file.
   if [ "$ssh_id" ]; then
      if [ -f "$ssh_id" ]; then
         ssh_id_opt="-i $ssh_id"
         return 0
      fi
   fi

   for i in id_vpn$local_hostnum id_vpn ; do
      for d in $pid_dir $vpnhome ; do
         if [ -f $d/$i ]; then
            ssh_id=$d/$i
            ssh_id_opt="-i $d/$i"
            return 0
         fi
      done
   done
   # No on-disk identity found
   ssh_id=
   ssh_id_opt=
   return 1
}

# Update ssh-agent in environment if needed.
#	- uses SSH_AUTH_SOCK local_hostnum agent_sock
#	- if our private agent is started, use it instead of
#	  any existing agent in environment.
get_agent() {
  # In some cases, we want to allow the personal agent of the
  # logged-in user to be used to initiate the tunnel, even though
  # this agent may not be available after the user disconnects.
  # If, however, the ssh2vpn-specific agent exists, it is assumed
  # to *override* the users personal agent.
  if [ -e $agent_sock ]; then
     # Agent is running, or, was started previously, so check it and
     # re-start it if necessary, updating Environment.
     run_agent
     return $?
  fi

  if [ "$SSH_AUTH_SOCK" ]; then
     # There is an existing personal agent.  We will use it instead.
     # NOTE: ssh-add -l rc=1 - no keys rc=2 could not connect to agent.
     ssh-add -l >/dev/null ; agent_rc=$?
     if [ $agent_rc -ne 2 ]; then
        bugme "using existing personal agent($SSH_AGENT_PID) $SSH_AUTH_SOCK"
        return $agent_rc
     fi
     # other agent not available.
     bugme "could not connect to agent ($SSH_AGENT_PID) $SSH_AUTH_SOCK"
  fi
  #
  # At this point, we continue without an agent
  return 2

  # In the future, if agent becomes manditory, then we would
  # start it here:
  #   run_agent
  #   return $?
}

# output agent in bourne syntax for eval
agent_bourne() {
  echo "export SSH_AUTH_SOCK=$SSH_AUTH_SOCK ;"
  if [ "$SSH_AGENT_PID" ]; then
     echo "export SSH_AGENT_PID=$SSH_AGENT_PID ;"
  else
     echo "unset SSH_AGENT_PID ;"
  fi
}

# Check for our agent running, and, start it if it is not.
# Environment is updated to reference our agent.
# rc is from ssh-add:
#	0 == running, with keys
#	1 == running, no keys
#	2 == failed
run_agent() {
 if [ "$SSH_AUTH_SOCK" ]; then
    if [ $SSH_AUTH_SOCK = $agent_sock ] ; then
       # our SSH_AUTH_SOCK already set.
       :
    else
       # Replace other personal agent in environment.
       SSH_AUTH_SOCK=$agent_sock
       if [ -f $agent_sock.run ]; then
          read SSH_AGENT_PID < $agent_sock.run
       else
          bugme "missing $agent_sock.run"
          unset SSH_AGENT_PID
       fi
    fi
    ssh-add -l >/dev/null ; agent_rc=$?
 else
    if [ -e $agent_sock ]; then
       export SSH_AUTH_SOCK=$agent_sock
       if [ -f $agent_sock.run ]; then
          read SSH_AGENT_PID < $agent_sock.run
       else
          bugme "missing $agent_sock.run"
          unset SSH_AGENT_PID
       fi
       ssh-add -l >/dev/null ; agent_rc=$?
    else
       agent_rc=2	# no agent
    fi
 fi
 if [ $agent_rc -eq 2 ]; then
    if [ "$SSH_AGENT_PID" ]; then
       log "Replacing ssh-agent ($SSH_AGENT_PID)"
       unset SSH_AGENT_PID
    fi
    [ -e $agent_sock ] && log "Previous agent failed?"

    # No agent, so start one that will use our socket.
    eval `ssh-agent -a $agent_sock`
    ssh-add -l >/dev/null ; agent_rc=$?
    if [ $agent_rc -eq 2 ]; then
       log "Error: failed to start ssh-agent."
       return 2
    fi
    echo $SSH_AGENT_PID > $agent_sock.run
 fi
 # agent started, or already running rc=1 indicates no-keys added.
 return $agent_rc
}

# start the agent, if needed, output bourne environment. Returns:
# 0 == running, with keys
# 1 == running, no keys
# 2 == failed
#
#parms: [start|stop|status|env]
do_agent() {
  op=${1:-status}
  case "$op" in
  start)	shift ; do_agent_start "$@" ; return $? ;;
  status)	do_agent_status ; return $?		;;
  add)		shift ; do_sshadd "$@" ; return $?	;;
  stop)		shift ; do_agent_stop "$@" ; return $?	;;
  *)	echo "Usage: ssh2vpn agent [start|stop|status|env]" >&2
  esac
}

do_agent_status() {
  local rc
  if vpn_agent; then
     ssh-add -l ; rc=$?
     echo "ssh2vpn agent($SSH_AGENT_PID) status=$rc"
     return $rc
  fi
  if [ "$SSH_AGENT_PID" ]; then
     echo "ssh2vpn agent($SSH_AGENT_PID) missing $agent_sock"
     return 3
  fi
  echo "ssh2vpn agent not running."
  return 2
}

do_agent_stop() {
   vpn_agent
   if [ "$SSH_AGENT_PID" ] ; then
	log "Stopping agent($SSH_AGENT_PID)"
	kill $SSH_AGENT_PID
	rm $agent_sock.run
	[ -e $agent_sock ] && sleep 1
   else
	echo "No ssh2vpn agent process found."
   fi
   [ -e $agent_sock ] && log "Warning: $agent_sock still present"
}

do_agent_start() {
   if vpn_agent; then
      echo "Already running." >&2
      return 0
   fi
   run_agent
   return $?
}

# Get the VPN agent into environment.
# No ssh-add is done to check on agent, however,
# we do check that the socket and pid exist.
# If the agent process does not exist, we don't check the socket.
vpn_agent() {
  local p e
  if [ -f $agent_sock.run ]; then
     read p < $agent_sock.run
     e=`readlink /proc/$p/exe`
     e=${e##*/}
     if [ "$e" = ssh-agent ]; then
        # Note that the SSH_AGENT_PID can be returned, even
        # if the socket is not present. I guess this could catch
        # a case where the agent is running, but didn't create the
        # socket.
        export SSH_AGENT_PID=$p
        if [ -e $agent_sock ]; then
           export SSH_AUTH_SOCK=$agent_sock
           return 0
        fi
        unset SSH_AUTH_SOCK
        return 3	# agent pid, but no socket
     fi
  fi
  unset SSH_AGENT_PID
  unset SSH_AUTH_SOCK
  return 1
}

# Do ssh-add command on our agent. Our agent must be started
# already.
#parms: ssh-add-parameters
do_sshadd() {
  if vpn_agent; then
     ssh-add "$@"
     return $?
  fi
  echo "Error: ssh2vpn no agent running." >&2
  return 2
}

#parms: hostnum|hostname CA-key [pubkey-file] [validity-period]
# Host key must be called {hostnum}.pub or {hostname}.pub
mkcert() {
  local hostnum pubkey permit validity

  [ -f "$2" ] || die "No CA key '$2' file found."
  host_to_num "$1" ; hostnum=$?
  if [ $hostnum -eq 0 ]; then
     die "unknown host: $1"
  fi
  if [ "$3" ]; then
     pubkey="$3"
  else
     pubkey="$1.pub"
     [ -f "$pubkey" ] || pubkey=$hostnum.pub
  fi
  [ -f "$pubkey" ] || die "No public key '$pubkey' found."

  read_prefix $hostnum host_prefix
  read_portfwd $hostnum host_portfwd

  permit="-O clear -O force-command='ssh2vpn force $host_prefix'"
  if $host_portfwd ; then
     permit="$permit -O permit-port-forwarding"
  fi
  if [ "$4" ]; then
     validity="$4"
  else
     read_validity $hostnum validity
  fi

  cmd="ssh-keygen -s '$2' $permit -V '$validity' -I ssh2vpn-$hostnum $pubkey"
  echo "$cmd"
  eval "$cmd" ; keygen_rc=$?
}

# Allow import of this script for unit testing.
[ "$_ssh2vpn_test" ] && return

#MAIN
if [ $# -eq 0 ]; then
   # no args, simply do status
   do_status
   exit $?
fi

case "$1" in
 start|persist)		do_start "$@"	;;
 stop)		shift ; do_stop "$@"	;;
 stat|status)	shift ; do_status "$@"	;;
 from)		shift ; do_from "$@"	;;	# name rnum lnum
 # The force option is expected to be use with something
 # like the following in /root/.ssh/authorized_keys2:
 # tunnel="5",no-pty,no-X11-forwarding,no-port-forwarding,no-user-rc,command="ssh2vpn force 5" ssh-rsa ...key ...comment
 #	- omit ,no-port-forwarding if you need socks proxy support
 #		hostsshopt NN -D PORT
 #
 # Question:
 #   Is it possible for some injection attack using SSH_ORIGINAL_COMMAND?
 #	- The bash shell-shock bug (fixed in 2014) is one example.
 #	- Are there other mechanisms? I don't want to quote the value
 #	  here, because I want the IFS splitting.
 #	- I suspect I should NEVER use SSH_ORIGINAL_COMMAND with eval.
 #
 force)		shift ; do_force "$@" $SSH_ORIGINAL_COMMAND	;;
 daemon)	shift ; daemon_cmd "$@"		;;	# rnum dest
 agent)		shift ; do_agent "$@"		;;	# just start agent
 add|addkey)	shift ; do_sshadd "$@"		;;	# ssh-add parms
 execssh)	shift ; exec_ssh_service "$@"	;;	# rnum dest
 servicetun)	shift ; service_tun "$@"	;;	# rnum
 mkcert)	shift ; mkcert "$@"		;;
 *)		die "unknown option: $*"
esac

# The functions above are expected to return a usefull value for
# the exit.
exit $?
